{"version":3,"sources":["sortingAlgorithms/sortingAlgorithms.js","SortingVisualizer/SortingVisualizer.jsx","App.js","serviceWorker.js","index.js"],"names":["mergeSortAnimations","array","animations","length","helper","slice","mergeSortHelper","left","right","middleIndex","Math","floor","i","j","k","push","quickSortAnimations","pivotAnimations","quickSortHelper","index","swap","temp","heapify","size","currMax","max","leftNode","rightNode","TOTAL_BARS","window","innerWidth","MAX_BAR_HEIGHT","innerHeight","MERGESORT_TOP_STACK","log2","SortingVisualizer","props","state","this","resetArray","barsArray","document","getElementsByClassName","style","backgroundColor","random","setState","bar1Index","bar2Index","bar1Style","bar2Style","color","setTimeout","newHeight","height","animationsArray","loopsOffset","pivotIndex","loops","pivotStyle","step","aIndex","aStyle","bIndex","heightA","heightB","bStyle","colorTemp1","newIndex","newStyle","iIndex","rightIndex","iHeight","rightHeight","iStyle","rightStyle","n","curr","heapSortAnimations","finishPivot","height1","height2","bubbleSortAnimations","className","map","value","idx","key","onClick","mergeSort","quickSort","heapSort","alert","bubbleSort","React","Component","App","Boolean","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.4a5570bf.chunk.js","sourcesContent":["export function mergeSortAnimations(array){\n    const animations = [];\n\n    //corner case\n    if (array.length <= 1){\n        return array;\n    }\n\n    const helper = array.slice();\n    mergeSortHelper(array, helper, animations, 0, array.length - 1);\n    return animations;\n}\n\nfunction mergeSortHelper(array, helper, animations, left, right) {\n    if (left === right){\n        return;\n    }\n    const middleIndex = Math.floor((right+left) / 2);\n    mergeSortHelper(helper, array, animations, left, middleIndex);\n    mergeSortHelper(helper, array, animations, middleIndex + 1, right);\n\n    //merging\n    let i = left, j = middleIndex + 1, k = left;\n    while (i <= middleIndex && j <= right){\n\n        //selecting two bars adding color\n        animations.push([i, j]);\n        //revert two bars to original color\n        animations.push([i, j]);\n\n        if (helper[i] < helper[j]){\n            animations.push([k, helper[i]]);\n            array[k++] = helper[i++];\n        } else {\n            animations.push([k, helper[j]]);\n            array[k++] = helper[j++];\n        }\n    }\n    //adding remaining numbers to original array\n    while(i <= middleIndex) {\n        animations.push([i, i]);\n        animations.push([i, i]);\n        animations.push([k, helper[i]]);\n        array[k++] = helper[i++];\n    }\n    while(j <= right){\n        animations.push([j, j]);\n        animations.push([j, j]);\n        animations.push([k, helper[j]]);\n        array[k++] = helper[j++];\n    }\n}\n\nexport function quickSortAnimations(array){\n    const pivotAnimations = [];\n    const animations = [];\n    if (array.length <= 1){\n        return array;\n    }\n    quickSortHelper(array, pivotAnimations, animations, 0, array.length - 1);\n    return [pivotAnimations, animations];\n}\n\nfunction quickSortHelper(array, pivotAnimations, animations, left, right){\n    if (left >= right){\n        return;\n    }\n\n    //const index = Math.floor(Math.random() * (right - left + 1) + left);\n    //however, for simplicity we set index to right for each stack.\n    const index = right;\n    pivotAnimations.push([index, right - left]); //1.1 highlight pivot index, and record while loop iterations.\n\n    let i = left, j = right - 1;\n    while (i <= j){\n\n        //2.1 highlight with comparing color\n        animations.push(i);\n\n        if (array[i] <= array[index]){\n\n            //2.2 swap heights and color\n            animations.push([i, i, array[i], array[i]]);\n            //2.3 revert its highlight color\n            animations.push(i);\n\n            i++;\n        } else {\n\n            //2.2 swap heights and color\n            animations.push([i, j, array[i], array[j]]);\n            //2.3 revert its highlight color\n            animations.push(j);\n\n            swap(array, i, j);\n            j--;\n        }\n    }\n\n    // 1.2 revert pivot highlight\n    pivotAnimations.push(index);\n    //1.3 swap back animation\n    pivotAnimations.push([i, index, array[i], array[index]]);\n\n    swap(array, i, right);\n\n    quickSortHelper(array, pivotAnimations, animations, left, i - 1);\n    quickSortHelper(array, pivotAnimations, animations, i + 1, right);\n\n}\n\nfunction swap(array, i, j){\n    const temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n}\n\nexport function heapSortAnimations(array){\n    const animations = [];\n\n    //corner cases\n    if (array.length <= 1){\n        return array;\n    }\n\n    const n = array.length;\n\n    //heapify\n    // \"curr = n / - 1\" represents the last internal nodes. takes O(n) time to achieve max heap\n    for (let curr = Math.floor(n / 2 - 1); curr >= 0; curr--){\n        heapify(array, animations, n, curr);\n    }\n\n    //sort\n    for (let i = n - 1; i >= 0; i--){\n\n        //animations explanation : 1. highlight 2. de-highlight 3. swap bars' heights\n        animations.push([0, i]);\n        animations.push([0, i]);\n        animations.push([0, i, array[0], array[i]]);\n\n        //swapping the current max to the right side -> achieve an ascending array.\n        swap(array, 0, i);\n\n        heapify(array, animations, i, 0);\n    }\n\n    return animations;\n}\n\nfunction heapify(array, animations, size, currMax){    // \"percolate down\"  -> becomes a max heap\n    let max = currMax;\n    let leftNode = currMax * 2 + 1;\n    let rightNode = currMax * 2 + 2;\n\n    if (leftNode < size && array[leftNode] > array[max]){\n        max = leftNode;\n    }\n    if (rightNode < size && array[rightNode] > array[max]){\n        max = rightNode;\n    }\n\n    if (max !== currMax){\n\n        animations.push([max, currMax]);\n        animations.push([max, currMax]);\n        animations.push([max, currMax, array[max], array[currMax]]);\n\n        swap(array, max, currMax);\n        heapify(array, animations, size, max);\n    }\n}\n\nexport function bubbleSortAnimations(array){\n    const animations = [];\n    if (array.length <= 1){\n        return array;\n    }\n    for (let i = 0; i < array.length - 1; i++){\n        for (let j = 0; j < array.length - 1 - i; j ++){\n\n            //adding color to the two comparing bars\n            animations.push([j, j + 1]);\n            //revert comparing colors\n            animations.push([j, j + 1]);\n\n            if (array[j] > array[j + 1]){\n                animations.push([j, j + 1, array[j], array[j + 1]]);\n                swap(array, j, j + 1);\n            } else {\n                animations.push([j, j, array[j], array[j]]);\n            }\n\n        }\n    }\n\n    return animations;\n}","import React from 'react';\nimport './SortingVisualizer.css';\nimport {bubbleSortAnimations, mergeSortAnimations, quickSortAnimations, heapSortAnimations} from '../sortingAlgorithms/sortingAlgorithms';\n\n//Constant Parameters:\nconst MAIN_COLOR = 'Teal';\nconst COMPARING_COLOR = 'Yellow';\nconst HIGHLIGHT_COLOR = 'Red';\nconst FINISH_COLOR = 'Purple';\nconst ANIMATION_SPEED = 3; //lower -> faster\nconst BUBBLE_SPEED = 0.2;\nconst TOTAL_BARS = window.innerWidth/5 - 30;\n//const TOTAL_BARS = 8; for testing use\n//90 is the button height plus margins for better display\nconst MAX_BAR_HEIGHT = window.innerHeight - 140;\n//total number of nodes on top stack of mergesort, used for changing finish_color\nconst MERGESORT_TOP_STACK = TOTAL_BARS * 3 * (Math.log2(TOTAL_BARS) - 1);\n\nexport default class SortingVisualizer extends React.Component {\n\n    constructor(props) {\n        super(props);\n\n        this.state = {\n            array: [],\n        };\n    }\n\n    componentDidMount() {\n        this.resetArray();\n    }\n\n    resetArray() {\n        const barsArray = document.getElementsByClassName('array-bar');\n        if (barsArray.length !== 0){\n            for (let i = 0; i < TOTAL_BARS; i++){\n                barsArray[i].style.backgroundColor = MAIN_COLOR;\n            }\n        }\n\n        const array = [];\n        for (let i = 0; i < TOTAL_BARS; i++){\n            array.push(randomIntGenerator(5, MAX_BAR_HEIGHT));\n        }\n        this.setState({array});\n    }\n\n    mergeSort(){\n        const animations = mergeSortAnimations(this.state.array);\n        const barsArray = document.getElementsByClassName('array-bar');\n        for (let i = 0; i < animations.length; i++){\n            const colorChanging = i % 3 !== 2;   //true, true, false\n            if (colorChanging){\n                const [bar1Index, bar2Index] = animations[i];\n                const bar1Style = barsArray[bar1Index].style;\n                const bar2Style = barsArray[bar2Index].style;\n                const color = i % 3 === 0 ? COMPARING_COLOR : MAIN_COLOR;\n                setTimeout(() => {\n                    bar1Style.backgroundColor = i >= MERGESORT_TOP_STACK? FINISH_COLOR : color;\n                    bar2Style.backgroundColor = i >= MERGESORT_TOP_STACK? FINISH_COLOR : color;\n                },  i * ANIMATION_SPEED);\n            } else {\n                setTimeout(() => {\n                    const [bar1Index, newHeight] = animations[i];\n                    const bar1Style = barsArray[bar1Index].style;\n                    bar1Style.height = `${newHeight}px`;\n                }, i* ANIMATION_SPEED);\n            }\n        }\n    }\n\n\n    quickSort(){\n        const animationsArray = quickSortAnimations(this.state.array);\n\n        const pivotAnimations = animationsArray[0];\n        const animations = animationsArray[1];\n\n        const barsArray = document.getElementsByClassName('array-bar');\n\n        let i = 0, loopsOffset = 0;\n        while (i < pivotAnimations.length){\n\n            //highlighting pivot and record number of while loops\n            const [pivotIndex, loops] = pivotAnimations[i];\n            const pivotStyle = barsArray[pivotIndex].style;\n            setTimeout(() => {\n                pivotStyle.backgroundColor = HIGHLIGHT_COLOR;\n            }, (i + loopsOffset) * ANIMATION_SPEED);\n\n            for (let j = 0; j < loops * 3; j++){\n\n                let step = (loopsOffset + j) % 3;\n                if (step === 0){\n                    const aIndex = animations[loopsOffset + j];\n                    const aStyle = barsArray[aIndex].style;\n                    setTimeout(() => {\n                        aStyle.backgroundColor = COMPARING_COLOR;\n                    }, (i+ j+loopsOffset) * ANIMATION_SPEED);\n                } else if (step === 1){\n                    const [aIndex, bIndex, heightA, heightB] = animations[loopsOffset + j];\n                    if (aIndex === bIndex){\n                        continue;\n                    }\n                    const aStyle = barsArray[aIndex].style;\n                    const bStyle = barsArray[bIndex].style;\n                    setTimeout(() => {\n                        const colorTemp1 = aStyle.backgroundColor;\n                        aStyle.backgroundColor = bStyle.backgroundColor;\n                        bStyle.backgroundColor = colorTemp1;\n                        aStyle.height = `${heightB}px`;\n                        bStyle.height = `${heightA}px`;\n                    }, (i+ j+loopsOffset) * ANIMATION_SPEED);\n                } else {  //j === 2\n                    const aIndex = animations[loopsOffset + j];\n                    const aStyle = barsArray[aIndex].style;\n                    setTimeout(() => {\n                        aStyle.backgroundColor = MAIN_COLOR;\n                    }, (i + j+loopsOffset) * ANIMATION_SPEED);\n                }\n            }\n            loopsOffset += loops * 3;\n\n            //revert pivot color\n            i++;\n            const newIndex = pivotAnimations[i];\n            const newStyle = barsArray[newIndex].style;\n            setTimeout(() => {\n                newStyle.backgroundColor = MAIN_COLOR;\n            }, (i+loopsOffset) * ANIMATION_SPEED);\n\n            //swap back pivot and color\n            i++;\n            const [iIndex, rightIndex, iHeight, rightHeight] = pivotAnimations[i];\n            const iStyle = barsArray[iIndex].style;\n            const rightStyle = barsArray[rightIndex].style;\n            setTimeout(() => {\n                iStyle.height = `${rightHeight}px`;\n                rightStyle.height = `${iHeight}px`;\n            }, (i+loopsOffset) * ANIMATION_SPEED);\n\n            i++;\n\n            if (i === pivotAnimations.length){\n                //finalizing - setting all bars to finish color\n                setTimeout(()=>{\n                    for (let i = 0; i < TOTAL_BARS; i++){\n                        barsArray[i].style.backgroundColor = FINISH_COLOR;\n                    }\n                }, (i + loopsOffset) * ANIMATION_SPEED);\n            }\n        }\n\n\n    }\n\n    heapSort() {\n\n        const animations = heapSortAnimations(this.state.array);\n        const barsArray = document.getElementsByClassName('array-bar');\n\n        let finishPivot = this.state.array.length - 1;\n        for (let i = 0; i < animations.length; i++) {\n            const colorChanging = i % 3 !== 2;   //true, true, false\n            if (colorChanging) {\n                const [bar1Index, bar2Index] = animations[i];\n                const bar1Style = barsArray[bar1Index].style;\n                const bar2Style = barsArray[bar2Index].style;\n                const color = i % 3 === 0 ? COMPARING_COLOR : MAIN_COLOR;\n                setTimeout(() => {\n                    bar1Style.backgroundColor = color;\n                    if (bar1Index === 0 && bar2Index === finishPivot){\n                        bar2Style.backgroundColor = FINISH_COLOR;\n                        finishPivot--;\n                    }\n                }, i * ANIMATION_SPEED);\n            } else {\n                const [bar1Index, bar2Index, height1, height2] = animations[i];\n                const bar1Style = barsArray[bar1Index].style;\n                const bar2Style = barsArray[bar2Index].style;\n                setTimeout(() => {\n                    bar1Style.height = `${height2}px`;\n                    bar2Style.height = `${height1}px`;\n                }, i * ANIMATION_SPEED);\n            }\n        }\n\n        //fix first bar exception -> finish color\n        setTimeout(() => {\n            barsArray[0].style.backgroundColor = FINISH_COLOR;\n        }, animations.length * ANIMATION_SPEED);\n    }\n\n    bubbleSort(){\n        const animations = bubbleSortAnimations(this.state.array);\n        const barsArray = document.getElementsByClassName('array-bar');\n        for (let i = 0; i < animations.length; i++){\n            let step = i % 3;\n            if (step === 2){\n                const [bar1Index, bar2Index, height1, height2] = animations[i];\n                const bar1Style = barsArray[bar1Index].style;\n                const bar2Style = barsArray[bar2Index].style;\n                setTimeout(() => {\n                    bar1Style.height = `${height2}px`;\n                    bar2Style.height = `${height1}px`;\n                }, i * BUBBLE_SPEED)\n            } else { // step == 1 / 2 color changing\n                const [bar1Index, bar2Index] = animations[i];\n                const bar1Style = barsArray[bar1Index].style;\n                const bar2Style = barsArray[bar2Index].style;\n                const color = step === 0 ? COMPARING_COLOR : MAIN_COLOR;\n                setTimeout(() => {\n                    bar1Style.backgroundColor = color;\n                    bar2Style.backgroundColor = color;\n                }, i * BUBBLE_SPEED)\n            }\n        }\n        setTimeout(()=>{\n            for (let i = 0; i < TOTAL_BARS; i++){\n                barsArray[i].style.backgroundColor = FINISH_COLOR;\n            }\n        }, (animations.length) * BUBBLE_SPEED);\n    }\n\n    render() {\n        const {array} = this.state;\n\n        return (\n\n            <div className=\"array-container\">\n                {array.map((value, idx) => (\n                    <div\n                        className=\"array-bar\"\n                        key={idx}\n                        style={{\n                            value: `${value}`,\n                            backgroundColor: MAIN_COLOR,\n                            height: `${value}px`,\n                        }}/>\n                ))}\n                <div className=\"new-button\" onClick={() => this.resetArray()}><div className=\"disable-select\">Generate New Array</div></div>\n                <div className=\"algorithm-button\" onClick={() => this.mergeSort()}><div className=\"disable-select\">Merge Sort</div></div>\n                <div className=\"algorithm-button\" onClick={() => this.quickSort()}><div className=\"disable-select\">Quick Sort</div></div>\n                <div className=\"algorithm-button\" onClick={() => this.heapSort()}><div className=\"disable-select\">Heap Sort</div></div>\n                <div className=\"algorithm-button\" onClick={() => {\n\n                    function bubbleAlert() {\n                        alert(\"Due to Bubble Sort's O(n^2) average time complexity, its Animation is speed up by 15 times faster\");\n                    }\n\n                    bubbleAlert(); this.bubbleSort()}}><div className=\"disable-select\">Bubble Sort</div></div>\n            </div>\n        );\n    }\n}\n\nfunction randomIntGenerator(left, right) {\n    return Math.floor(Math.random() * (right - left + 1) + left);\n}\n\n\n","import React from 'react';\nimport SortingVisualizer from './SortingVisualizer/SortingVisualizer';\nimport './App.css';\n\nfunction App() {\n    let div = <>\n        <div className=\"App\">\n            <div className=\"website-header\"><div className=\"disable-select\">Sorting Algorithms Visualizer</div></div>\n            <SortingVisualizer></SortingVisualizer>\n        </div>\n    </>;\n    return div;\n}\nexport default App;\n\n//TODO:把buttons放到单独的files，保证在bars的下面","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}